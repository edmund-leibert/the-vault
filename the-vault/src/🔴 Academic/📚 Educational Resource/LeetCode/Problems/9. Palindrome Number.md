---
title: 9. Palindrome Number
created: 2023-09-19 18:36
updated: 2024-04-14T00:24
authors:
  - Edmund Leibert III
tags:
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ”–/problems/9-palindrome-number
  - ğŸ”´-academic/ğŸ“š-educational-resource/format/internet
  - ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/premium/ğŸ”“-no
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/difficulty/easy
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/tag/topic/math
  - study-note
cards-deck: ğŸ”´ Academic::ğŸ“š Educational Resource::LeetCode::Problems::9. Palindrome Number
banner: "![[https://i.imgur.com/ISVPGZz.png]]"
banner_y: 0
---

# 9. Palindrome Number

---

> [!INFO]+ Note
> This page contains notes pertaining to the LeetCode problem [9. Palindrome Number](https://leetcode.com/problems/palindrome-number/) [@leetcodePalindromeNumber].
>
> These notes are primarily structured in a Q&A format, making it easy to follow and learn. Corresponding [**Anki**](https://apps.ankiweb.net/) flashcards are available, enabling efficient revision and reinforcement of the concepts [@ankitectsAnkiPowerfulIntelligent].
> 
> Performance of attempts are also recorded.

---

> [!INFO]+ Note
> **Previous Notes**:
> 

---

## :TiNotes: Description

ï¹‡<br>
As of Feb. 10, 2024 01:44:54 PM, in **LeetCode**â€™s terms, specifically in the scope of problem **9. Palindrome Number**, when is an integer `x` a _**palindrome**_?

#anki-card 

As defined in the problem statement:
> An integer is aÂ **palindrome**Â when it reads the same forward and backward.
> 
> For example,Â `121`Â is a palindrome whileÂ `123`Â is not.

> [!WARNING]+ Warning
> Be aware that _negative_ integers are **not** palindromes.
> 
> **Example 2:** <br>
> > **Input:** x = -121 <br>
> > **Output:** false <br>
> > **Explanation:** From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

âŒ‚
<br>ï¹ˆ<br>^1707601524572

## :BoBxBookOpen: Editorial

ï¹‡<br>
As discussed in the **LeetCode** Editorial for this problem, what are some approaches to this problem? Identify the **most** optimal. If there are multiple approaches, and multiple equally optimal solutions, identify them as well. 

Lastly, make sure to list out the **time** and **space** complexity for each approach!

#anki-card 

| Approach                              | Time Complexity | Space Complexity |
|---------------------------------------|-----------------|------------------|
| Approach 1: Revert half of the number | $\mathcal{O}(\log_{10}(n))$     | $\mathcal{O}(1)$             |

âŒ‚
<br>ï¹ˆ<br>^1707601604151

ï¹‡<br>
When creating tables in Excel, Markdown, etc., is it convention to have the column headers of tables be **plural** _or_ **singular**?

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/business/technology/microsoft-excel 

The convention for naming column headers in tables can depend on the context and the specific data being represented. [However, column headers are usually singular because they often represent a list of individual parameters](https://forum.wordreference.com/threads/table-head-single-form-or-plural-form.2141313/) [@lqztransTableHeadSingle2011] [@qubeiAnswerColumnTitles2014]. [For example, you might have a column header â€œHeightâ€ representing the height of each individual in a dataset, rather than â€œHeightsâ€ for all individuals](https://forum.wordreference.com/threads/table-head-single-form-or-plural-form.2141313/) [@lqztransTableHeadSingle2011] [@qubeiAnswerColumnTitles2014].

That being said, there are cases where plural column headers might be more appropriate. [For instance, if a column contains multiple values or a set of similar items for each row, a plural header might make more sense](https://forum.wordreference.com/threads/table-head-single-form-or-plural-form.2141313/) [@lqztransTableHeadSingle2011] [@qubeiAnswerColumnTitles2014].

[Ultimately, the most important thing is to choose column headers that accurately represent the data in each column and are clear and understandable to anyone using the table](https://www.baeldung.com/cs/database-table-column-naming-conventions) [@kumarDatabaseTableColumn2023] [@qubeiAnswerColumnTitles2014]. [Consistency in naming conventions should be maintained throughout the entire table](https://forum.wordreference.com/threads/table-head-single-form-or-plural-form.2141313/) [@kumarDatabaseTableColumn2023] [@qubeiAnswerColumnTitles2014]. [In a team setting, all team members should know and follow the established conventions](https://forum.wordreference.com/threads/table-head-single-form-or-plural-form.2141313/) [@kumarDatabaseTableColumn2023] [@qubeiAnswerColumnTitles2014].

Remember, these are just common practices and may vary between different projects. [Itâ€™s always a good idea to check the specific guidelines for the project youâ€™re working on](https://www.baeldung.com/cs/database-table-column-naming-conventions) [@kumarDatabaseTableColumn2023] [@qubeiAnswerColumnTitles2014].

âŒ‚
<br>ï¹ˆ<br>^1707601980571

## :RiFlaskLine: Solutions

## :RiHistoryLine: Submissions

### :SiPython: Python

#### **Attempt #1** â€¢ ğŸ“† 2024-02-10 05:48 -07:00 â€¢ âŒ Failed â€¢ â±ï¸ 0:24:30 â€¢ \[Author(s): Edmund Leibert III\]

ï¹‡<br>
Mathematically, what is the formal definition of integers?

#anki-card 

An **integer** is a mathematical concept that encompasses several types of numbers. Letâ€™s dive into the formal definitions:

1. **Definition 1 (Commonly Used)**:
    
    - [An integer is the number **zero (0)**, a **positive natural number** (such as 1, 2, 3, etc.), or a **negative integer** (such as -1, -2, -3, etc.)](https://en.wikipedia.org/wiki/Integer)[1](https://en.wikipedia.org/wiki/Integer).
    - The **negative numbers** are the **additive inverses** of the corresponding positive numbers.
    - [The set of all integers is often denoted by the boldface **Z** or blackboard bold](https://en.wikipedia.org/wiki/Integer) [1](https://en.wikipedia.org/wiki/Integer).
2. **Definition 2 (Set-Theoretic Approach)**:
    
    - Integers can be defined as the **difference between two natural numbers**.
    - Natural numbers themselves can be defined as the **number of elements in a set**.
    - [These definitions do not depend on any specific **number base**; they are independent of how we represent numbers symbolically](https://en.wikipedia.org/wiki/Integer) [2](https://math.stackexchange.com/questions/1787084/what-is-an-integer).
3. **Additional Insight**:
    
    - We can also think of integers as the numbers we can obtain from **0 and 1** by **adding, subtracting, and multiplying**, but never dividing.
    - [This perspective avoids the need to bring up number bases altogether and highlights the agreement across different number bases](https://en.wikipedia.org/wiki/Integer) [2](https://math.stackexchange.com/questions/1787084/what-is-an-integer).

In summary, integers are whole numbers that can be positive, negative, or zero, without any fractional part. They play a fundamental role in mathematics and various applications. ğŸ§®

âŒ‚
<br>ï¹ˆ<br>


ï¹‡<br>
As of Feb. 10, 2024 01:55:58 PM, what is the approach to finding the **digit** of an **integer** at a position?

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/python 



âŒ‚
<br>ï¹ˆ<br>


### :SiCplusplus: C++

#### **Attempt #2** â€¢ ğŸ“† 2024-09-19 18:48 -07:00 â€¢ âŒ Failed â€¢ â±ï¸ 0:24:35 â€¢ \[Author(s): Edmund Leibert III\]

ï¹‡<br>
Without converting to a string, in C++, how you get _solely_ the 0<sup>th</sup>, or last position, of a number. How about the first digit of a number?

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

In C++, one way you can find the  the 0<sup>th</sup> (i.e., the least significant digit), last (most significant), and first digits of a number _without_ converting it to a string is by simply using mathematical operations. Here's how to do it:

**For the 0th (least significant) digit**:
The 0th digit is just the remainder when the number is divided by 10. You can get it using the `%` operator.

```cpp
int number = 12345;
int leastSignificantDigit = number % 10;  // This will give you 5
```

**For the last (most significant) digit**:
To find the last or most significant digit, you can keep dividing the number by 10 until it becomes a single-digit number.

```cpp
int number = 12345;
while (number >= 10) {
    number /= 10;
}
// Now, number contains the most significant digit, which is 1 in this case.
```

**For the first digit after the most significant digit**:
To find the first digit after the most significant digit, you can first find the most significant digit as explained above and then use it to remove the most significant digit from the number. After that, the most significant digit of the resulting number will be the first digit after the original most significant digit.

```cpp
int number = 12345;
int originalNumber = number;
while (number >= 10) {
    number /= 10;
}

// Remove the most significant digit from the original number
int firstDigitAfterMSD = (originalNumber % static_cast<int>(pow(10, static_cast<int>(log10(originalNumber))))) / pow(10, static_cast<int>(log10(originalNumber)) - 1);
```

Here, `firstDigitAfterMSD` will contain the first digit after the most significant digit (which is 2 in this case).

âŒ‚
<br>ï¹ˆ<br>^1707601524595


ï¹‡<br>
What is a general function to get a number at $n$ digit from right to left?

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

To retrieve the digit at the \(n\)th position from the right (0-based index), you can divide the number by $10^n$ and then take the remainder after division by 10. Here's a general function for that in C++:

```cpp
#include <cmath>
#include <iostream>

int getDigitAtN(int number, int n) {
    if (n < 0 || n >= static_cast<int>(std::log10(number) + 1)) {
        // Return -1 if n is out of bounds
        return -1;
    }
    int divisor = std::pow(10, n);
    return (number / divisor) % 10;
}

int main() {
    int number = 12345;
    int n = 2;
    int digit = getDigitAtN(number, n);
    if (digit != -1) {
        std::cout << "The digit at position " << n << " from the right is: " << digit << std::endl;
    } else {
        std::cout << "Invalid position specified." << std::endl;
    }
    return 0;
}
```

In this example, `getDigitAtN(12345, 2)` would return 3 because the $2^{\text{nd}}$ digit from the right in the number 12345 is 3.

âŒ‚
<br>ï¹ˆ<br>^1707601524600



ï¹‡<br>
To retrieve the digit at the \(n\)th position from the right (0-based index), you can divide the number by $10^n$ and then take the remainder after division by 10. Here's a general function for that in C++:

```cpp
#include <cmath>
#include <iostream>

int getDigitAtN(int number, int n) {
    if (n < 0 || n >= static_cast<int>(std::log10(number) + 1)) {
        // Return -1 if n is out of bounds
        return -1;
    }
    int divisor = std::pow(10, n);
    return (number / divisor) % 10;
}

int main() {
    int number = 12345;
    int n = 2;
    int digit = getDigitAtN(number, n);
    if (digit != -1) {
        std::cout << "The digit at position " << n << " from the right is: " << digit << std::endl;
    } else {
        std::cout << "Invalid position specified." << std::endl;
    }
    return 0;
}
```

Is there any downside or limitation/bounds with the following approach?

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Certainly, there are a few limitations and downsides to this approach:

Type and Size Limitations

1. **Integer Size**: The approach assumes that the input number can be stored in a standard `int`. If the number is too large (or too small if it's negative), the behavior could be undefined.
2. **Floating-Point Numbers**: This approach doesn't cover floating-point numbers; it's designed for integers.

Error Handling

3. **Negative Position**: The function returns -1 if the digit position \( n \) is out of bounds. You might want to throw an exception or provide more specific error handling, depending on your use case.
4. **Negative Numbers**: The function does not account for negative numbers. If you pass a negative number, it would technically still get a digit but might not behave as expected depending on what you want to achieve with negative numbers.

Computational Overheads

5. **Logarithmic and Exponential Operations**: The use of `std::log10` and `std::pow` introduces computational overhead, especially for very large numbers.
6. **Floating-Point Errors**: Functions like `std::log10` and `std::pow` work with floating-point numbers and may introduce tiny errors.

Readability

7. **Complexity**: For someone unfamiliar with the math behind it, this approach might be harder to understand than a string-based approach.

Corner Cases

8. **Zero and Single-Digit Numbers**: For the number 0 or any single-digit number, $\log_{10}(number)$ would be zero or negative, which could cause issues if not handled.

âŒ‚
<br>ï¹ˆ<br>^1707601524605



ï¹‡<br>
What does this snippet of code actually do?

```cpp
n >= static_cast<int>(std::log10(number) + 1)
```

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

The expression `n >= static_cast<int>(std::log10(number) + 1)` is used for bounds checking, specifically to check if the requested digit position \( n \) is within the range of the number's digits.

Here's the breakdown:

1. `std::log10(number)`: This returns the base-10 logarithm of the number, which essentially tells you how many digits the number has, minus 1. For example, $\log_{10}(1000) = 3, \log_{10}(999) = 2.999$, and so on.

2. `std::log10(number) + 1`: Adding 1 adjusts for the off-by-one issue arising from logarithm. This is important for numbers like 999 which have 3 digits but a logarithm value of 2.999.

3. `static_cast<int>(std::log10(number) + 1)`: This converts the float value to an integer, effectively rounding it down to the nearest integer. This gives the total number of digits in the integer part of the number.

1. `n >= static_cast<int>(std::log10(number) + 1)`: This checks if $n$ is outside the range of digits that the number actually has. If $n$ is equal to or greater than the total number of digits, the function should return an error or a specific value to indicate out-of-bounds.

For example, for the number 12345, $\log_{10}(12345) = 4.0915$. Adding 1 gives 5.0915, and casting to `int` gives 5. That means 12345 has 5 digits. If $n$ is 5 or greater, it's out of bounds for this number.

âŒ‚
<br>ï¹ˆ<br>^1707601524610



ï¹‡<br>
Does static casting to `int` (e.g., `static_cast<int>`) always rounds down? 

What happens if I am applying it on a negative number like -4.3534?

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

No, this is wrong.

In C++, the `static_cast<int>` conversion for floating-point numbers truncates the decimal part, effectively rounding towards zero. It does not round to the nearest integer; rather, it simply discards the fractional part.

1. **Positive Numbers**: For positive floating-point numbers, this behavior is effectively the same as rounding down.
    - Example: `static_cast<int>(4.3534)` would yield `4`.
2. **Negative Numbers**: For negative floating-point numbers, rounding towards zero is effectively the same as rounding up when considering the absolute value.
    - Example: `static_cast<int>(-4.3534)` would yield `-4`.

Here, `static_cast<int>(-4.3534)` will give you `-4`, not `-5`, because it truncates towards zero.

âŒ‚
<br>ï¹ˆ<br>^1707601524615


The `std::log10()` function returns {1:`nan`} under certain conditions, one of which is when the argument passed to it is {2:zero} or {2:negative}. This is because logarithm is undefined for non-positive numbers. #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 
^1707601524626



ï¹‡<br>
What does the following code snippet do?

```cpp
int revertedNumber = 0;
while(x > revertedNumber) {
	revertedNumber = revertedNumber * 10 + x % 10;
	x /= 10;
}
```

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

The code snippet reverses the digits of the variable `x` and stores the reversed part in `revertedNumber`. However, it only reverses the digits until `revertedNumber` becomes greater than or equal to `x`.

Here's a step-by-step explanation:

1. `int revertedNumber = 0;`: Initializes a variable `revertedNumber` to zero, which will hold the reversed digits.
   
2. `while(x > revertedNumber)`: The loop will continue as long as `x` is greater than `revertedNumber`.

    - `revertedNumber = revertedNumber * 10 + x % 10;`: In each iteration, the last digit of `x` is added to `revertedNumber` after shifting the digits of `revertedNumber` one place to the left (multiplying by 10).
    
    - `x /= 10;`: Removes the last digit from `x`.

Here's an example with `x = 12345`:

- Iteration 1: `revertedNumber = 0 * 10 + 5 = 5`, `x = 1234`
- Iteration 2: `revertedNumber = 5 * 10 + 4 = 54`, `x = 123`
- Iteration 3: `revertedNumber = 54 * 10 + 3 = 543`, `x = 12`
- Iteration 4: `revertedNumber = 543 * 10 + 2 = 5432`, `x = 1`

The loop will break at this point because `x (1)` is not greater than `revertedNumber (5432)`.

This kind of operation is often seen in problems where you need to reverse an integer or check for palindromic integers.

âŒ‚
<br>ï¹ˆ<br>^1707601524630




ï¹‡<br>
How do you get the length of a number that is zero or negative?

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

For zero or negative numbers, you can employ a different approach. Here are some methods:

**Zero**

The number zero (`0`) has a single digit. So, its length is 1.

**Negative Numbers**

For negative numbers, you can convert them to positive by taking the absolute value and then apply the log10 method to find the length. In C++, you can use the `std::abs()` function from the `<cmath>` header to get the absolute value.

Here's a function that handles zero and negative numbers as well:

```cpp
#include <cmath>
#include <iostream>

int getLength(int number) {
    if (number == 0) {
        return 1;
    }
    number = std::abs(number); // Convert negative numbers to positive
    return static_cast<int>(std::log10(number) + 1);
}

int main() {
    std::cout << "Length of 0: " << getLength(0) << std::endl;
    std::cout << "Length of -123: " << getLength(-123) << std::endl;
    std::cout << "Length of 123: " << getLength(123) << std::endl;
    return 0;
}
```

This code snippet defines a function `getLength` that:
1. Returns 1 if the number is zero.
2. Takes the absolute value of negative numbers using `std::abs()`.
3. Applies the `log10 + 1` formula to calculate the length of the absolute value.

Would you like to make this into an Anki flashcard for easier review?

âŒ‚
<br>ï¹ˆ<br>^1707601524634

#### **Attempt #1** â€¢ ğŸ“† 2023-23-07 18:39 -07:00 â€¢ âŒ Failed â€¢ â±ï¸ 0:21:00 â€¢ \[Author(s): Edmund Leibert III\]

ï¹‡<br>
How can I get the last digit of a number greater than or equal to 0? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Simply divide the modulo by

```cpp
int num = 432;
lastDigit = 432 % 10;
```

âŒ‚
<br>ï¹ˆ<br>^1707601524639


ï¹‡<br>
What does the following code return? 

```cpp
int num = 432155
std::cout << num % std::pow(10,5);
```

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

- Prints out the followingâ€¦ `32155`
- Note how that this method returns **all** digits up to, from right-to-left, the $n$ position (where $n=5$ in the above case).

âŒ‚
<br>ï¹ˆ<br>^1707601524642


ï¹‡<br>
How can one â€œvectorizeâ€ an `int` (i.e., split up all elements/digits into a container?)

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

The most common, or efficient way is to use recursion.
```cpp
void vectorize_int(int num, std::vector<int> &numVector) {
	if(num > 9) {
		vectorize_int(num / 10, numVector);
	}
	numVector.push_back(num % 10);
}
```
The time complexity of this algorithm isâ€¦
- Time Complexity: $\mathcal{O}(\log_{10}$`num`$)$
- Space Complexity: $\mathcal{O}(\log_{10}$`num`$)$

âŒ‚
<br>ï¹ˆ<br>^1707601524646


ï¹‡<br>
How do you calculate the length of a positive integer?

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Simply use the `std::log10()` and `std::floor()` function from the `<cmath>` library
```cpp
std::floor(std::log10(num)) + 1;
```

âŒ‚
<br>ï¹ˆ<br>^1707601524650


ï¹‡<br>
What is the time complexity of the following function?

```cpp
std::floor(std::log10(num)) + 1;
```

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

The time complexity of the following function is $\mathcal{O}(n)$ where $n$ is the amount of digits in the integer.

âŒ‚
<br>ï¹ˆ<br>^1707601524654


ï¹‡<br>
What is the time complexity of the function `std::stoi()`? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

While it can achieve $\mathcal{O}(1)$, if there is no leading whitespace, it usually just $\mathcal{O}$(`str.length()`)

âŒ‚
<br>ï¹ˆ<br>^1707601524657


ï¹‡<br>
Can negative numbers be considered palindromes? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

No.

âŒ‚
<br>ï¹ˆ<br>^1707601524660


ï¹‡<br>
What does $\text{mod}(54456,10^3)$ equal? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

Equals 456. Remember that this expression all numbers (from right-to-left) the values **up to** the exponent that of 10.

âŒ‚
<br>ï¹ˆ<br>^1707601524664



ï¹‡<br>
Is zero a palindrome? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

Recall that for a number to be a palindrome, it, and the reverse of itself must be equal. 

Considering that for any number ending in zero, the reverse of it would have to start with zero, we can deduce that 0 is the ***only*** valid number â€œendingâ€ in zero that can be a palindrome.

âŒ‚
<br>ï¹ˆ<br>^1707601524667



ï¹‡<br>
Is 10 a palindrome? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

No.

âŒ‚
<br>ï¹ˆ<br>^1707601524671


ï¹‡<br>
What are some immediate edge cases I need to be thinking about for the problem? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

- $0$ is the only number ending in zero that is a palindrome.
- Negative numbers are not palindromes.

âŒ‚
<br>ï¹ˆ<br>^1707601524675



ï¹‡<br>
What library is `std::floor()` from? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

From the library `<cmath>`.

âŒ‚
<br>ï¹ˆ<br>^1707601524680



ï¹‡<br>
What is wrong with the following code?

```cpp
int num = 32345;
int numLength = std::floor(std::log10(num)) + 1;
```

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

Forgetting to do the `static_cast<int>()` to ensure that the return type of the right side of that statement returns an `int`.

âŒ‚
<br>ï¹ˆ<br>^1707601524683



ï¹‡<br>
What must I **always remember to f\*cking do** when I am using a `while` loop? 

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

**REMEMBER TO F\*CKING INCREMENT THE ITERATOR**
- Every time you make that mistake it is a 2 minute plank you fat lard.

âŒ‚
<br>ï¹ˆ<br>^1707601524686



ï¹‡<br>
When building edge cases, especially for this problem, what is something I must mind when writing code for my base cases? 
 
#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  
 
Keep in mind the ranges of our `if-else` Boolean checks and that they are not short circuiting.

âŒ‚
<br>ï¹ˆ<br>^1707601524690




ï¹‡<br>
What is wrong with the following code?

```cpp
if(numLength % 2 == 1) {
	x / 10;
}
```

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

Not updating the code!

âŒ‚
<br>ï¹ˆ<br>^1707601524694



ï¹‡<br>
What is the problem with the following code?

```cpp
int numLength = static_cast<int>( std::floor(std::log10(x)) + 1 );
int i = {0};
int halfX {0};

while(i < std::floot(numLength/2) ) {
	int lastDigit = x % 10;
	x = x / 10;
	halfX = halfX * 10;
	halfX += lastDigit;
	i++;
}
```

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

Not accounting for case in loop where the value is just a single digit. Correction belowâ€¦

```cpp
int numLength = static_cast<int>( std::floor(std::log10(x)) + 1 );
int i {0};
int halfX {0};
while(i < std::floor(numLength/2) ) {
	int lastDigit = x % 10;
	x = x / 10;
	if(i >= 1) { // If we are not at the first digit.
		halfX = halfX * 10;
	}
	halfX += lastDigit;
	i++;
}
```

âŒ‚
<br>ï¹ˆ<br>^1707601524698


ï¹‡<br>
How do I get the *lower* half of an **odd** or **even** number. For example, an input of `9` would return `3`. Or, an input of `4` would return `2`.

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

```cpp
int lowerHalf = std::floor(num / 2);
```

âŒ‚
<br>ï¹ˆ<br>^1707601524702


ï¹‡<br>
What is wrong with the following code? 

```cpp
int x = {0};
```

#anki-card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp  

This is **copy initialization**, should prefer to use **list initialization**.

âŒ‚
<br>ï¹ˆ<br>^1707601524707





---

## :EiZoteroItem: Bibliography

---

> [!INFO] Note
> **Next Notes:**

---
